# PyCatan â€” Blog Post 1: Architecture & Design Decisions

*Note: This post is available in both Hebrew and English. English version follows the Hebrew section.*

---

## ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª

### ×¨×§×¢ ×•××˜×¨×•×ª ×”×¤×¨×•×™×§×˜

×¤×¨×•×™×§×˜ ×”×’××¨ ×©×œ×™ ××ª××§×“ ×‘×‘× ×™×™×ª ×©×›×‘×ª ×¡×™××•×œ×¦×™×” ××œ××” ××¢×œ ×¡×¤×¨×™×™×ª `pycatan` ×”×§×™×™××ª. ×”×¡×¤×¨×™×™×” ×”××§×•×¨×™×ª ××¡×¤×§×ª ××™××•×© ×‘×¡×™×¡×™ ×©×œ ×—×•×§×™ ×”××©×—×§ Settlers of Catan, ××š ×—×¡×¨×” ×œ×” ×ª×©×ª×™×ª ×œ× ×™×”×•×œ ××©×—×§ ××œ×, ×ª××™×›×” ×‘×¡×•×’×™ ×©×—×§× ×™× ×©×•× ×™×, ×•×××©×§×™ ×ª×¦×•×’×”.

**×”××˜×¨×” ×”××¨×›×–×™×ª:** ×œ×‘× ×•×ª ×¤×œ×˜×¤×•×¨××” ××•×“×•×œ×¨×™×ª ×©×ª××¤×©×¨:
- × ×™×”×•×œ ××©×—×§ ××•×˜×•××˜×™ ×¢× ×›×œ×œ×™ ×ª×•×¨×•×ª ××œ××™×
- ×ª××™×›×” ×‘×©×—×§× ×™× ×× ×•×©×™×™× ×•-AI ×‘××•×ª×” ××¢×¨×›×ª
- ×•×™×–×•××œ×™×–×¦×™×” ×‘×–××Ÿ ×××ª (Console + Web)
- ×‘×¡×™×¡ ×œ×”×¨×—×‘×” ×¢×ª×™×“×™×ª ×©×œ ×ª×§×©×•×¨×ª ×‘×™×Ÿ-×¡×•×›× ×™× (Multi-Agent Systems)

### ×”×—×œ×˜×•×ª ××“×¨×™×›×œ×™×•×ª

×‘×©×œ×‘ ×”×ª×›× ×•×Ÿ ×”×¨××©×•× ×™ ×–×™×”×™×ª×™ ×©×”×‘×¢×™×” ×”××¨×›×–×™×ª ×”×™× **×”×¤×¨×“×ª ××—×¨×™×•×ª** (Separation of Concerns). ×”××©×—×§ ×”×§×™×™× ××›×™×œ ××ª ×”×œ×•×’×™×§×”, ××š ×œ× ×™×•×“×¢ ×“×‘×¨ ×¢×œ ×–×¨×™××ª ×ª×•×¨×•×ª, ×©×—×§× ×™×, ××• ×ª×¦×•×’×”. ×œ×›×Ÿ ×‘× ×™×ª×™ ××ª ×”××¢×¨×›×ª ×‘×©×›×‘×•×ª:

#### 1. Game Layer (Core Logic)
×”×©×›×‘×” ×”×§×™×™××ª. ××›×™×œ×” ××ª ×›×œ ×—×•×§×™ ×”××©×—×§: ×‘× ×™×”, ××¡×—×¨, ×§×œ×¤×™ ×¤×™×ª×•×—, ×ª× ××™ × ×™×¦×—×•×Ÿ.
- **××—×¨×™×•×ª:** Validation ×©×œ ×¤×¢×•×œ×•×ª, ×‘×™×¦×•×¢ ×©×™× ×•×™×™× ×‘××¦×‘ ×”××©×—×§
- **×œ× ××—×¨××™×ª ×¢×œ:** ×–×¨×™××ª ×ª×•×¨×•×ª, ×‘×—×™×¨×ª ×¤×¢×•×œ×•×ª, ×ª×¦×•×’×”

#### 2. GameManager (Orchestration Layer)
×”×©×›×‘×” ×©×¤×™×ª×—×ª×™ ×œ× ×™×”×•×œ ×–×¨×™××ª ×”××©×—×§.
- **××—×¨×™×•×ª:** Game loop, × ×™×”×•×œ ×ª×•×¨×•×ª, ×ª×™××•× ×‘×™×Ÿ Users ×œ-Game
- **×ª×¤×§×™×“ ××¨×›×–×™:** ××ª×¢×“ ××ª ×¨×¦×£ ×”×¤×¢×•×œ×•×ª ×•××‘×˜×™×— ×‘×™×¦×•×¢ ×—×•×§×™

#### 3. User Abstraction
×××©×§ ××—×™×“ ×œ×§×‘×œ×ª ×”×—×œ×˜×•×ª ××›×œ ×¡×•×’ ×©×—×§×Ÿ.
- `User` (abstract) â†’ ×××©×§ ×‘×¡×™×¡×™
- `HumanUser` â†’ parser ×œ×¤×§×•×“×•×ª CLI
- `AIUser` â†’ decision-making ××œ×’×•×¨×™×ª××™

×”×¢×™×§×¨×•×Ÿ: GameManager ×œ× ×¦×¨×™×š ×œ×“×¢×ª **××™** ××§×‘×œ ××ª ×”×”×—×œ×˜×”, ×¨×§ **××”** ×”×”×—×œ×˜×”.

#### 4. Visualization Layer
×ª×¦×•×’×” ×× ×•×ª×§×ª ××”×œ×•×’×™×§×”.
- `ConsoleVisualization` â†’ output ×¦×‘×¢×•× ×™ ×œ×˜×¨××™× ×œ
- `WebVisualization` â†’ Flask + SSE ×œ×¢×“×›×•× ×™× ×‘×–××Ÿ ×××ª

**×¢×™×§×¨×•×Ÿ ×× ×—×”:**
```
Game     = What is allowed (rules)
Manager  = When and how (flow)
User     = What to do (decisions)
Visualization = How to present (display)
```

### Actions Model: Protocol Between Components

×‘×¢×™×” ×©×–×™×”×™×ª×™ ××•×§×“×: ××™×š Users ××ª×§×©×¨×™× ×¢× Game ×‘×¦×•×¨×” ××—×™×“×”?

**×”×¤×ª×¨×•×Ÿ:** ××•×“×œ `Action` ×¡×˜× ×“×¨×˜×™.

×›×œ ×¤×¢×•×œ×” ×‘××©×—×§ ××™×•×¦×’×ª ×›××•×‘×™×™×§×˜:
```python
@dataclass
class Action:
    type: ActionType
    args: Dict[str, Any]
```

**×™×ª×¨×•× ×•×ª ×”×’×™×©×”:**
1. **Validation ××¨×›×–×™×ª** - GameManager ×™×›×•×œ ×œ×‘×“×•×§ ×ª×§×™× ×•×ª ×œ×¤× ×™ ×‘×™×¦×•×¢
2. **Serialization** - ×§×œ ×œ×©××•×¨/×œ×©×“×¨ ×¤×¢×•×œ×•×ª (×—×©×•×‘ ×œ-AI agents)
3. **Visualization** - ×”×ª×¨××•×ª ××—×™×“×•×ª ×œ×›×œ ×”×××©×§×™×
4. **AI Planning** - AI ×™×›×•×œ ×œ×™×™×¦×¨ ×¨×©×™××ª Actions ×•×œ×‘×—×•×¨ ××•×¤×˜×™××œ×™×ª

**×“×•×’××” ××”×§×•×“:**


```python
from pycatan.actions import Action, ActionType

# User ××—×–×™×¨ Action object
action = Action(
    type=ActionType.ADD_SETTLEMENT,
    args={
        'player': 0,
        'point': board.points[0][0],
        'is_starting': True
    }
)

# GameManager validates and executes
status = game.add_settlement(**action.args)
if status == Statuses.OK:
    visualization.notify_action(action, status)
```

### User Abstraction: Polymorphic Decision Making

×”×—×œ×˜×” ××¨×›×–×™×ª: ×›×œ ×¡×•×’ ×©×—×§×Ÿ ×× ××© ××ª ××•×ª×• ×××©×§.

```python
class User(ABC):
    @abstractmethod
    def get_input(self, game_state: GameState) -> Optional[Action]:
        """Return next action based on current game state."""
        pass
```

**××™××•×©×™× × ×•×›×—×™×™×:**

1. **HumanUser** - Parser ×œ×¤×§×•×“×•×ª ×˜×§×¡×˜:
   - `build settlement 0 0` â†’ `Action(ADD_SETTLEMENT, {...})`
   - ×ª××™×›×” ×‘-15+ ×¡×•×’×™ ×¤×§×•×“×•×ª
   - Error handling ×•-suggestions

2. **AIUser** - Decision algorithm (×‘×¤×™×ª×•×—):
   - ××§×‘×œ `GameState`
   - ××¢×¨×™×š ××¤×©×¨×•×™×•×ª
   - ××—×–×™×¨ `Action` ××•×¤×˜×™××œ×™

**×ª×•×›× ×™×•×ª ×¢×ª×™×“×™×•×ª:**
Multi-Agent Communication Layer - AI agents ×™×•×›×œ×• ×œ× ×”×œ ××©× ×•××ª×Ÿ:
```python
# Future concept
ai1.propose_trade(ai2, offer={Wood: 2}, request={Brick: 1})
ai2.evaluate_and_respond()  # Returns acceptance/counter-offer
```

### Architecture Diagram

```mermaid
flowchart TB
    subgraph External["External Layer"]
        H[HumanUser]
        AI[AIUser]
    end
    
    subgraph Core["Core Game Logic"]
        G[Game<br/>Rules & State]
    end
    
    subgraph Orchestration["Orchestration Layer"]
        GM[GameManager<br/>Game Loop]
    end
    
    subgraph Display["Visualization Layer"]
        CV[ConsoleViz]
        WV[WebViz]
    end
    
    H -->|get_input| GM
    AI -->|get_input| GM
    GM -->|Action| G
    G -->|Status| GM
    GM -->|notify_action| CV
    GM -->|notify_action| WV
    GM -->|update_state| CV
    GM -->|update_state| WV
    
    style Core fill:#e1f5ff
    style Orchestration fill:#fff4e1
    style External fill:#f0f0f0
    style Display fill:#e8f5e9
```

### Current Status & Next Steps

**×”×•×©×œ× ×¢×“ ×›×” (× ×›×•×Ÿ ×œ-06/12/2025):**
- âœ… Actions model + 15 action types
- âœ… User abstraction (Human + AI base)
- âœ… GameManager core loop
- âœ… ConsoleVisualization (color-coded, real-time)
- âœ… WebVisualization (Flask + SSE)
- âœ… 75 unit tests

**×‘×¢×‘×•×“×”:**
- ğŸ”„ Turn rules (dice, robber, discard on 7)
- ğŸ”„ Integration testing (end-to-end game simulation)

**×¤×•×¡×˜×™× ×¢×ª×™×“×™×™×:**
1. ××™××•×© ×—×•×§×™ ×ª×•×¨×•×ª - ×”××ª×’×¨×™× ×‘× ×™×”×•×œ ×”-Robber ×•-discard
2. Trade system - ××©× ×•××ª×Ÿ ×‘×™×Ÿ ×©×—×§× ×™× (approval flow)
3. Web visualization deep-dive - SSE, board rendering, real-time sync
4. AI player implementation - decision trees ×•××¡×˜×¨×˜×’×™×”

---

## ğŸ‡ºğŸ‡¸ English Version

### Project Background & Objectives

This capstone project focuses on building a complete simulation layer on top of the existing `pycatan` library. The original library provides basic Settlers of Catan game logic implementation, but lacks infrastructure for full game management, support for different player types, and display interfaces.

**Core Objective:** Build a modular platform that enables:
- Automatic game management with complete turn rules
- Support for both human and AI players in the same system
- Real-time visualization (Console + Web)
- Foundation for future multi-agent communication systems

### Architectural Decisions

During initial planning, I identified that the core challenge was **Separation of Concerns**. The existing game contains the logic but knows nothing about turn flow, players, or display. Therefore, I built the system in layers:

#### 1. Game Layer (Core Logic)
The existing layer. Contains all game rules: building, trading, development cards, victory conditions.
- **Responsible for:** Action validation, game state mutations
- **Not responsible for:** Turn flow, action selection, display

#### 2. GameManager (Orchestration Layer)
The layer I developed for game flow management.
- **Responsible for:** Game loop, turn management, coordinating Users with Game
- **Core role:** Documents action sequence and ensures legal execution

#### 3. User Abstraction
Uniform interface for receiving decisions from any player type.
- `User` (abstract) â†’ base interface
- `HumanUser` â†’ CLI command parser
- `AIUser` â†’ algorithmic decision-making

Principle: GameManager doesn't need to know **who** makes the decision, only **what** the decision is.

#### 4. Visualization Layer
Display decoupled from logic.
- `ConsoleVisualization` â†’ colored terminal output
- `WebVisualization` â†’ Flask + SSE for real-time updates

**Guiding Principle:**
```
Game     = What is allowed (rules)
Manager  = When and how (flow)
User     = What to do (decisions)
Visualization = How to present (display)
```

### Actions Model: Inter-Component Protocol

Early problem identified: How do Users communicate with Game uniformly?

**Solution:** Standardized `Action` model.

Every game action is represented as an object:
```python
@dataclass
class Action:
    type: ActionType
    args: Dict[str, Any]
```

**Approach Benefits:**
1. **Centralized validation** - GameManager can check validity before execution
2. **Serialization** - Easy to store/transmit actions (important for AI agents)
3. **Visualization** - Uniform notifications for all interfaces
4. **AI Planning** - AI can generate action lists and choose optimally

**Code Example:**

```python
from pycatan.actions import Action, ActionType

# User returns Action object
action = Action(
    type=ActionType.ADD_SETTLEMENT,
    args={
        'player': 0,
        'point': board.points[0][0],
        'is_starting': True
    }
)

# GameManager validates and executes
status = game.add_settlement(**action.args)
if status == Statuses.OK:
    visualization.notify_action(action, status)
```

### User Abstraction: Polymorphic Decision Making

Central decision: All player types implement the same interface.

```python
class User(ABC):
    @abstractmethod
    def get_input(self, game_state: GameState) -> Optional[Action]:
        """Return next action based on current game state."""
        pass
```

**Current Implementations:**

1. **HumanUser** - Text command parser:
   - `build settlement 0 0` â†’ `Action(ADD_SETTLEMENT, {...})`
   - Supports 15+ command types
   - Error handling and suggestions

2. **AIUser** - Decision algorithm (in development):
   - Receives `GameState`
   - Evaluates options
   - Returns optimal `Action`

**Future Plans:**
Multi-Agent Communication Layer - AI agents can negotiate:
```python
# Future concept
ai1.propose_trade(ai2, offer={Wood: 2}, request={Brick: 1})
ai2.evaluate_and_respond()  # Returns acceptance/counter-offer
```

### Architecture Diagram

(Same diagram as Hebrew section - visual language is universal)

### Current Status & Next Steps

**Completed so far (as of 06/12/2025):**
- âœ… Actions model + 15 action types
- âœ… User abstraction (Human + AI base)
- âœ… GameManager core loop
- âœ… ConsoleVisualization (color-coded, real-time)
- âœ… WebVisualization (Flask + SSE)
- âœ… 75 unit tests

**In Progress:**
- ğŸ”„ Turn rules (dice, robber, discard on 7)
- ğŸ”„ Integration testing (end-to-end game simulation)

**Future Posts:**
1. Turn rules implementation - Robber & discard management challenges
2. Trade system - Inter-player negotiation (approval flow)
3. Web visualization deep-dive - SSE, board rendering, real-time sync
4. AI player implementation - Decision trees and strategy
